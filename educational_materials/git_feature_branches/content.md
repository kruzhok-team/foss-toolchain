# Recap

## Чек-лист

* Умею создать локальный репозиторий
```bash
git init
```

* Умею склонировать удаленный репозиторий https://github.com/abc/xyz.git

```bash
git clone https://github.com/abc/xyz.git
```

* Умею склонировать удаленный репозиторий https://github.com/abc/xyz.git

```bash
git remote add staging https://github.com/abc/xyz.git
```

* Умею настроить .gitigonore так, чтобы в репозиторий не попадали артифакты запуска и сборки, например файлы, например файлы все с расширением pyc. (строка в файле .gitignore)

```bash
*.pyc
```

* Умею добавить отдельный файл в staging area. Например README.md

```bash
git add README.md
```

* Умею посмотреть изменения в рабочей директории по сравнению с зафиксированной (закомиченной версией).


```bash
git diff
```

* Умею откатить изменения опреленного файла до последней закомиченной версии. Например README.md

```bash
git checkout README.md
```

* Умею переключиться на другую ветку, которая существует. Например development.

```bash
 git checkout development
```

* Умею создать ветку локально и переключиться на нее. Например featrure-add-logs

```bash 
git checkout -b featrure-add-logs
```

* Умею отправить свои (локальные) изменения в определенную ветку (например feature-user-config) определенного удаленного (например sandbox) репозитория

```bash
git push sandbox feature-user-config
```

* Умею забрать изменения в локальную ветку с определенной ветки (например feature-user-config)  определенного удаленного (например sandbox) репозитория и сразу применить изменения в workspace

```bash
git pull sandbox feature-user-config
```

* Умею отменить последний коммит сделанный локально, но еще не отправленный в удаленный репозиторий

```bash
git reset HEAD~
```


* Умею проверить локально какие коммиты были сделаны в репозитории.

```bash
git log
```

* Умею слить две ветки локально, например изменения из master в ветку feature-user-login. Сейчас мы находимся на ветке feature-user-login

```bash
git merge master
```

Умею отменить команду запрос на разрешение конфликта (после git merge)

```bash
git merge --abort
git reset --hard
```

* Умею создать форк проекта
* Умею создать задачу (issue) на github или gitlab
* Умею создать запрос на принятие изменений (merge/pull request)



Команды, котрых хватит в большинстве случаев:

![git basic flow](https://user-images.githubusercontent.com/14274827/91470661-9d5a8780-e8b2-11ea-9ccb-0d813d2e35d1.png)

Немного более подробно по поводу разных обоастей:

![git merging](https://cloudstudio.com.au/wp-content/uploads/2021/06/GitWorkflow-4.png)

# Организация работы в GIT

Алиса и Федор, два разработчика, только что получили новое задание: создать веб-приложение Python для клиента. Они оба были рады работать вместе, но знали, что им нужен надежный инструмент для эффективного сотрудничества и поддержания организованности проекта. Вот где в игру вступили Git и GitHub.

## Настройка репозитория

Проект начался в простом локальном каталоге на компьютере Алисы. Она инициализировала репозиторий Git локально и создала начальный код перед подключением его к удаленному репозиторию на GitHub.

Алиса создала новый каталог для проекта и инициализировала локальный репозиторий Git:

```bash 
mkdir item_keeper
cd item_keeper
git init
```

Затем она начала разрабатывать проект, выбрав [FastAPI](https://fastapi.tiangolo.com/#requirements) в качестве веб-фреймворка. Она создала новый файл Python с именем main.py со следующим кодом:

```python 
from fastapi import FastAPI

app = FastAPI()

@app.get("/")
def read_root():
    return {"message": "Hello, World!"}
```

Теперь изменения нужно зафиксировать:

```bash
git add main.py
git commit -m "Initial commit with FastAPI setup"
```

Создадим **пустой** репозиторий на github и получим дальнейшие инструкции.

```bash 
#…or create a new repository on the command line

echo "# test" >> README.md
git init
git add README.md
git commit -m "first commit"
git branch -M main
git remote add origin https://github.com/alice/item_keeper.git
git push -u origin main

#…or push an existing repository from the command line

git remote add origin https://github.com/alice/item_keeper.git
git branch -M main
git push -u origin main
```

Так как локальный репозиторий уже создан актуальна вторая опция. Воспользовавшись ей она 
она может подключить удаленный репозиторий для того, чтобы синхронизировать свой:

```bash
# change https://github.com/alice/item_keeper.git to actual URL when using
git remote add origin https://github.com/alice/item_keeper.git
```

Чтобы работать надо проектом совместно, Федор должен склонировать репозиторий после того как 
Алиса создала его. 

```bash
git clone https://github.com/alice/item_keeper.git
```

Теперь, когда локальный репозиторий Алисы был подключен к удаленному, она может отправить 
свои изменения на GitHub:

```bash
git push -u origin main
```

Теперь изменения должны быть доступны на странице проекта на GitHub.

## Первая задача

Федор начал работать над файлом README.md, чтобы добавить краткое описание проекта. Он создал 
файл и добавил следующее содержание:

```bash
# Item keeper

Keep and returns items to user
```

Он выполнил команды, чтобы зафиксировать изменения и отправить их на GitHub:

```bash
git add README.md
git commit -m "Added description of the app"
git push origin main

error: failed to push some refs to 'https://github.com/alice/item_keeper.git'
hint: Updates were rejected because the remote contains work that you do not have locally.
hint: Before pushing, pull the latest changes from the remote repository.
```

Федор быстро понял, что Алиса уже отправила свои изменения в удаленный репозиторий. 
Ему нужно было загрузить последние изменения из удаленного репозитория в свой 
локальный репозиторий, прежде чем отправлять свои собственные. Федор выполнил 
команды:

```bash
git pull origin main
```

> На этом этапе не должны возникнуть merge-конфликты, так как разработчики работали с разными 
файлами. Но, если вы с коллегами поправили у себя один и тот же файл, то будут конфликты,
которые нужно разрешить.

> Так же если вы делаете `git pull` до коммита, может возникнуть сообщение от git, что сначала 
нужно закоммитить локальные изменения, пержде чем забирать чужие, сделайте это, обычно git 
плохого не посоветует

## Работа в feature branches

После успешной настройки проекта и внесения первоначальных изменений Алиса и Федор решили, 
что пришло время более эффективно организовать рабочий процесс. Им нужен был способ работать 
над новыми функциями, не мешая основной ветке или прогрессу друг друга. Решение? Работа
в feature branches.

### Всегда нужно договариваться

Алиса и Федор договорились о следующем рабочем процессе:

* Основная ветка всегда будет содержать стабильный, готовый к производству код.
* Для каждой новой функции или задачи они будут создавать новую ветку из основной.
* После завершения функции они откроют запрос на включение (запрос на слияние) для 
слияния ветки функции с основной.

Таким образом, они смогут изолировать свою работу, организовать изменения кода и 
избежать конфликтов слияния.

## Первая фича

Первой функцией, которую нужно было добавить, была конечная точка для возврата списка 
доступных элементов в приложении. Алиса решила заняться этой задачей. Алиса создала 
новую ветку с именем feature/items-endpoint:

```bash
git checkout -b feature/items-endpoint
```

И добавила функцию:

```python
from fastapi import FastAPI

app = FastAPI()

@app.get("/")
def read_root():
    return {"message": "Hello, World!"}

@app.get("/items")
def get_items():
    return {"items": ["item1", "item2", "item3"]}
```

Алиса протестировала новую конечную точку локально, чтобы убедиться, что она работает 
так, как ожидалось. Когда она была удовлетворена, она зафиксировала свои изменения:

```bash 
git add main.py
git commit -m "Add /items endpoint to return a list of items"
```

Теперь можно отправить их в удаленный репозиторий:

```bash
git push origin feature/items-endpoint
```

### Открытие запроса на извлечение

На GitHub Алиса перешла в репозиторий, выбрала ветку feature/items-endpoint и нажала 
«new pull request». Она добавила заголовок и комментарий:

* Заголовок: Добавить запрос /items для возврата списка элементов
* Описание: Этот запрос на извлечение добавляет новую конечную точку (/items) для 
возврата списка предопределенных элементов. После создания запроса на извлечение 
она назначила Федора рецензентом.

## Принятие 

Федор получил уведомление о запросе на извлечение Алиса. Он просмотрел изменения кода 
на GitHub, протестировал ветку локально, перенеся ее на свою машину:

```bash 
git fetch origin feature/items-endpoint
git checkout feature/items-endpoint
```

Удовлетворенный реализацией Алисы, Федор одобрил запрос на извлечение и объединил его 
с основной веткой на GitHub. После объединения Федор забрал последние изменения с удаленного
репозитория.

```bash 
git checkout main
git pull origin main
```

## И повторяем цикл

Теперь очередь Федор поработать над функцией. Он решил добавить конечную точку для извлечения
определенного элемента по его идентификатору. Следуя тому же процессу, он создал новую ветку:

```bash
git checkout -b feature/item-by-id-endpoint
```

Он написал новую функциональность, зафиксировал изменения, отправил ветку и открыл запрос на
 извлечение. Алиса проверила и объединила его, обеспечив плавный рабочий процесс.



